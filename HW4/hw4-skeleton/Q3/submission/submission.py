
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: Q3.ipynb

import numpy as np
import pandas as pd
import time
import gc
import random
from sklearn.model_selection import cross_val_score, GridSearchCV, cross_validate, train_test_split
from sklearn.metrics import accuracy_score, classification_report
from sklearn.svm import SVC
from sklearn.linear_model import LinearRegression
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler, normalize
from sklearn.decomposition import PCA
from sklearn.impute import SimpleImputer

class GaTech():
    # Change to your GA Tech Username
    def GTusername(self):
        gt_username = "zpatwary3"
        return gt_username

class Data():

    # points [1]
    def dataAllocation(self,path):
        # TODO: Separate out the x_data and y_data and return each
        # args: string path for .csv file
        # return: pandas dataframe, pandas series
        # -------------------------------
        # ADD CODE HERE
        df = pd.read_csv('./data/pima-indians-diabetes.csv')
        x_data = df.iloc[:, df.columns != "y"]
        y_data = df.iloc[:,-1:]
        y_data = y_data.squeeze()
        #print(type(x_data))
        #print(type(y_data))
        # -------------------------------


        return x_data,y_data

    # points [1]
    def trainSets(self,x_data,y_data):
        # TODO: Split 70% of the data into training and 30% into test sets. Call them x_train, x_test, y_train and y_test.
        # Use the train_test_split method in sklearn with the parameter 'shuffle' set to true and the 'random_state' set to 614.
        # args: pandas dataframe, pandas dataframe
        # return: pandas dataframe, pandas dataframe, pandas series, pandas series
        # -------------------------------
        # ADD CODE HERE

        x_train, x_test, y_train, y_test = train_test_split( x_data, y_data, test_size=0.30, random_state=614)

        # -------------------------------
        return x_train, x_test, y_train, y_test

##################################################
##### Do not add anything below this line ########
##################################################

class LinearRegressionModel():

    # points [2]
    def linearClassifier(self, x_train, x_test, y_train):
        # TODO: Create a LinearRegression classifier and train it.
        # args: pandas dataframe, pandas dataframe, pandas series
        # return: numpy array, numpy array
        # -------------------------------
        # ADD CODE HERE

        lr = LinearRegression()
        lr.fit(x_train, y_train)
        y_predict_train = lr.predict(x_train)
        y_predict_test = lr.predict(x_test)

        # -------------------------------
        return y_predict_train, y_predict_test

    # points [1]
    def lgTrainAccuracy(self, y_train, y_predict_train):
        # TODO: Return accuracy (on the training set) using the accuracy_score method.
        # Note: Round the output values greater than or equal to 0.5 to 1 and those less than 0.5 to 0. You can use any method that satisfies the requriements.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        y_pred = []
        for i in y_predict_train:
            if i >= 0.5:
                y_pred.append(1)
            else:
                y_pred.append(0)
        train_accuracy = accuracy_score(y_pred, y_train)
        # print("Train Accuracy: ", train_accuracy)
        # -------------------------------
        # print(type(train_accuracy.item()))
        return train_accuracy.item()

    # points [1]
    def lgTestAccuracy(self, y_test, y_predict_test):
        # TODO: Return accuracy (on the testing set) using the accuracy_score method.
        # Note: Round the output values greater than or equal to 0.5 to 1 and those less than 0.5 to 0. You can use any method that satisfies the requriements.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        y_pred = []
        for i in y_predict_test:
            if i >= 0.5:
                y_pred.append(1)
            else:
                y_pred.append(0)
        test_accuracy = accuracy_score(y_pred, y_test)
        # test_accuracy = accuracy_score(y_predict_test, y_test)

        # -------------------------------
        return test_accuracy.item()



##################################################
##### Do not add anything below this line ########
##################################################

class RFClassifier():

    # points [2]
    def randomForestClassifier(self,x_train,x_test, y_train):
        # TODO: Create a RandomForestClassifier and train it. Set Random state to 614.
        # args: pandas dataframe, pandas dataframe, pandas series
        # return: RandomForestClassifier object, numpy array, numpy array
        # -------------------------------
        # ADD CODE HERE

        rf = RandomForestClassifier(random_state=614)
        rf.fit(x_train, y_train.values.ravel())
        y_predict_train = rf.predict(x_train)
        y_predict_test = rf.predict(x_test)
        rf_clf = rf

        # -------------------------------
        return rf_clf,y_predict_train, y_predict_test

    # points [1]
    def rfTrainAccuracy(self,y_train,y_predict_train):
        # TODO: Return accuracy on the training set using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        y_predict_train = y_predict_train.round()
        train_accuracy = accuracy_score(y_predict_train, y_train)

        # -------------------------------
        return train_accuracy

    # points [1]
    def rfTestAccuracy(self,y_test,y_predict_test):
        # TODO: Return accuracy on the test set using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        y_predict_test = y_predict_test.round()
        test_accuracy = accuracy_score(y_predict_test, y_test)

        # -------------------------------
        return test_accuracy

# Q3.3.1 Feature Importance

    # points [1]
    def rfFeatureImportance(self,rf_clf):
        # TODO: Determine the feature importance as evaluated by the Random Forest Classifier.
        # args: RandomForestClassifier object
        # return: float array
        # -------------------------------
        # ADD CODE HERE

        # array with features highest to lowest
        feature_importance = rf_clf.feature_importances_
        # feature_importance = np.argsort(fea_impo)[::-1]
        # feature_importance = feature_importance.astype(float)
        #
        # feat = []
        # for i in feature_importance:
        #     feat.append(i.item())
        #
        #
        # #print(feat)
        #
        # feature_importance = feat
        #
        # # -------------------------------
        return feature_importance

    # points [1]
    def sortedRFFeatureImportanceIndicies(self,rf_clf):
        # TODO: Sort them in the ascending order and return the feature numbers[0 to ...].
        #       Hint: There is a direct function available in sklearn to achieve this. Also checkout argsort() function in Python.
        # args: RandomForestClassifier object
        # return: int array
        # -------------------------------
        # ADD CODE HERE

        # importances = rf_clf.feature_importances_
        # std = np.std([tree.feature_importances_ for tree in rf_clf.estimators_], axis=0)
        # indices = np.argsort(importances)[::-1]
        # sorted_indices = np.argsort(indices)
        # sorted_indices = sorted_indices.tolist()
        importances = rf_clf.feature_importances_
        # std = np.std([tree.feature_importances_ for tree in rf_clf.estimators_], axis=0)
        sorted_indices = np.argsort(importances)

        # sorted_indices = sorted_indices.tolist()

        # -------------------------------
        return sorted_indices

# Q3.3.2 Hyper-parameter Tuning

    # points [2]
    def hyperParameterTuning(self,rf_clf,x_train,y_train):
        # TODO: Tune the hyper-parameters 'n_estimators' and 'max_depth'.
        # args: RandomForestClassifier object, pandas dataframe, pandas series
        # return: GridSearchCV object
        # 'n_estimators': [4, 16, 256]
        # 'max_depth': [2, 8, 16]
        # -------------------------------
        # ADD CODE HERE
        #print("RFCLF: ", rf_clf)
        param = {'n_estimators': [4, 16, 256], 'max_depth': [2, 8, 16]}
        gscv_rfc = GridSearchCV(estimator = rf_clf, param_grid = param)
        gscv_rfc.fit(x_train, y_train)
        #print("MODEL TYPE : ", type(model))
        #gscv_rfc = rf_tune
        #print("RFTUNE: ", gscv_rfc)
        # -------------------------------
        return gscv_rfc

    # points [1]
    def bestParams(self,gscv_rfc):
        # TODO: Get the best params, using .best_params_
        # args:  GridSearchCV object
        # return: parameter dict
        # -------------------------------
        # ADD CODE HERE

        best_params = gscv_rfc.best_params_

        # -------------------------------
        return best_params

    # points [1]
    def bestScore(self,gscv_rfc):
        # TODO: Get the best score, using .best_score_.
        # args: GridSearchCV object
        # return: float
        # -------------------------------
        # ADD CODE HERE

        best_score = gscv_rfc.best_score_
        #print("BEST SCORE TYPE: ", type(best_score))
        # -------------------------------
        return best_score.item()

##################################################
##### Do not add anything below this line ########
##################################################

class SupportVectorMachine():

# Q3.4.1 Pre-process

    # points [1]
    def dataPreProcess(self,x_train,x_test):
        # TODO: Pre-process the data to standardize it, otherwise the grid search will take much longer.
        # args: pandas dataframe, pandas dataframe
        # return: pandas dataframe, pandas dataframe
        # -------------------------------
        # ADD CODE HERE
        scaler = StandardScaler()
        scaler.fit(x_train)
        scaled_x_train = scaler.transform(x_train)
        scaled_x_test = scaler.transform(x_test)

        # -------------------------------
        return scaled_x_train, scaled_x_test

# Q3.4.2 Classification

    # points [1]
    def SVCClassifier(self,scaled_x_train,scaled_x_test, y_train):
        # TODO: Create a SVC classifier and train it. Set gamma = 'auto'
        # args: pandas dataframe, pandas dataframe, pandas series
        # return: numpy array, numpy array
        # -------------------------------
        # ADD CODE HERE
        svm_cf = SVC(gamma = 'auto')
        svm_cf.fit(scaled_x_train, y_train)
        y_predict_train = svm_cf.predict(scaled_x_train)
        y_predict_test = svm_cf.predict(scaled_x_test)

        # -------------------------------
        return y_predict_train,y_predict_test

    # points [1]
    def SVCTrainAccuracy(self,y_train,y_predict_train):
        # TODO: Return accuracy on the training set using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        train_accuracy = accuracy_score(y_predict_train, y_train)

        # -------------------------------
        return train_accuracy

    # points [1]
    def SVCTestAccuracy(self,y_test,y_predict_test):
        # TODO: Return accuracy on the test set using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        test_accuracy = accuracy_score(y_predict_test, y_test)

        # -------------------------------
        return test_accuracy

# Q3.4.3 Hyper-parameter Tuning

    # points [1]
    def SVMBestScore(self, scaled_x_train, y_train):
        # TODO: Tune the hyper-parameters 'C' and 'kernel' (use rbf and linear).
        # Note: Set n_jobs = -1 and return_train_score = True and gamma = 'auto'
        # args: pandas dataframe, pandas series
        # return: GridSearchCV object, float
        # -------------------------------
        # ADD CODE HERE

        svm_param = {'kernel': ('linear', 'rbf'), 'C': [0.01, 0.1, 1.0]}
        svm_cv = GridSearchCV(estimator=SVC(gamma='auto'), param_grid=svm_param, n_jobs=-1, return_train_score=True)
        svm_cv.fit(scaled_x_train, y_train)
        best_score = svm_cv.best_score_
        # print("BS TYPE: ", type(best_score))

        # print("SVM CV: ", svm_cv)

        # -------------------------------

        return svm_cv, best_score.item()
    # points [1]
    def SVCClassifierParam(self,svm_cv,scaled_x_train,scaled_x_test,y_train):
        # TODO: Calculate the training and test set accuracy values after hyperparameter tuning and standardization.
        # args: GridSearchCV object, pandas dataframe, pandas dataframe, pandas series
        # return: numpy series, numpy series
        # -------------------------------
        # ADD CODE HERE

        y_predict_train = svm_cv.predict(scaled_x_train)
        y_predict_test = svm_cv.predict(scaled_x_test)

        # -------------------------------
        return y_predict_train,y_predict_test

    # points [1]
    def svcTrainAccuracy(self,y_train,y_predict_train):
        # TODO: Return accuracy (on the training set) using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE.

        train_accuracy = accuracy_score(y_predict_train, y_train)

        # -------------------------------
        return train_accuracy

    # points [1]
    def svcTestAccuracy(self,y_test,y_predict_test):
        # TODO: Return accuracy (on the test set) using the accuracy_score method.
        # args: pandas series, numpy array
        # return: float
        # -------------------------------
        # ADD CODE HERE

        test_accuracy = accuracy_score(y_predict_test, y_test)


        # -------------------------------
        return test_accuracy

# Q3.4.4 Cross Validation Results

    # points [1]
    def SVMRankTestScore(self,svm_cv):
        # TODO: Return the rank test score for all hyperparameter values that you obtained in Q3.4.3. The
        # GridSearchCV class holds a 'cv_results_' dictionary that should help you report these metrics easily.
        # args: GridSearchCV object
        # return: int array
        # -------------------------------
        # ADD CODE HERE

        rank_test_score = svm_cv.cv_results_['rank_test_score']

        # -------------------------------
        return rank_test_score

    # points [1]
    def SVMMeanTestScore(self,svm_cv):
        # TODO: Return mean test score for all of hyperparameter values that you obtained in Q3.4.3. The
        # GridSearchCV class holds a 'cv_results_' dictionary that should help you report these metrics easily.
        # args: GridSearchCV object
        # return: float array
        # -------------------------------
        # ADD CODE HERE

        mean_test_score = svm_cv.cv_results_['mean_test_score']

        # -------------------------------
        return mean_test_score

##################################################
##### Do not add anything below this line ########
##################################################

class PCAClassifier():

    # points [2]
    def pcaClassifier(self,x_data):
        # TODO: Perform dimensionality reduction of the data using PCA.
        #       Set parameters n_components to 8 and svd_solver to 'full'. Keep other parameters at their default value.
        # args: pandas dataframe
        # return: pca_object
        # -------------------------------
        # ADD CODE HERE
        pca_cf = PCA(n_components = 8, svd_solver = 'full')
        pca = pca_cf.fit(x_data)

        # -------------------------------
        return pca

    # points [1]
    def pcaExplainedVarianceRatio(self, pca):
        # TODO: Return percentage of variance explained by each of the selected components
        # args: pca_object
        # return: float array
        # -------------------------------
        # ADD CODE HERE

        explained_variance_ratio = pca.explained_variance_ratio_

        # -------------------------------
        return explained_variance_ratio

    # points [1]
    def pcaSingularValues(self, pca):
        # TODO: Return the singular values corresponding to each of the selected components.
        # args: pca_object
        # return: float array
        # -------------------------------
        # ADD CODE HERE

        singular_values = pca.singular_values_

        # -------------------------------
        return singular_values

##################################################
##### Do not add anything below this line ########
##################################################